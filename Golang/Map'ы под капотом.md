[[map'ы]]

Вот по сути та же map'a (те же ключ и значения. Но по факту это массив структур и кол-во операций будет выполняться по **O(n)**) ![[Pasted image 20260104064211.png]]

### Чтобы все операции выполнялись за константное время мы сортируем по бакетам.
![[Pasted image 20251224145350.png]]
### Чтобы распределить элементы таким образом нам нужна хэш функция(некое преобразование которое применяем к ключу и на выходе получаем номер бакета).

**Хэш-функция должна соответствовать следующим требованиям:**
- Равномерность(всё должно быть равномерно распределено между бакетами)
- Быстрота
- Детерминированность(Для одного и того же ключа - тот же номер бакета)
- Криптоустойчивость(нельзя чтобы все элементы попадали в один и тот же бакет)

Все операции выполняюстя через `unsafe.Pointers`, используем **type descriptor(`*_type) `***
он описывает любой тип данных для компиляции

Вид мапы под капотом:
```go
type mapType struct {
    typ     *_type    // базовый _type
    key     *_type    // тип ключа
    elem    *_type    // тип значения
    bucket  *_type    // тип bucket (bmap)
    hasher  func(unsafe.Pointer, uintptr) uintptr
    keysize uint8     // размер ключа
    indirectkey bool  // ключ по указателю?
    valuesize uint8
    indirectvalue bool
    bucketsize uint16 // размер бакета
    reflexiveKey bool
    needkeyupdate bool
    comparator func(unsafe.Pointer, uintptr, unsafe.Pointer, uintptr) bool
}
```

**Как компилируется эта строка?**
```
v = m[k]
```

```go
	v := m[k]
	pk := unsafe.Pointer(&k)
	func lookup(t *mapType, //дескриптор типа мапы(данные о типах ключей, значений и прочие метаданные)
		 m *mapHeader, //указатель на заголовок конкретной мапы
		 k unsafe.Pointer //указатель на ключ(то что положили в pk)
		 ) unsafe.Pointer 

	pv := runtime.lookup(typeOf(m), //компилятор узнаёт тип m и подставляет нужный тип *mapType по сути это дескриптор
	 m, pk) //передаём просто мапу и указатель на ключ
	 unsafe.Pointer  //получаем указатель из ф-ции выше
	v = *(*V)pv 
	//pv (unsafe.Pointer) приводит к указателю на конкретный тип(*V) 
	//дальше разыменование указателя и приходим к значениб ключа
```

А вот так различные операции выглядят в runtime'е go-шки:
```go
// 1. v := m["k"]
{
    pk := unsafe.Pointer(&"k")
    t := getMapType(m)   // *maptype
    h := getHmap(m)      // *hmap

    pv := mapaccess1(t, h, pk) // unsafe.Pointer
    v := *(*V)(pv)             // V — реальный тип значения
}

```

```go
// 2. v, ok := m["k"]
{
    pk := unsafe.Pointer(&"k")
    t := getMapType(m)
    h := getHmap(m)

    pv, ok := mapaccess2(t, h, pk) // unsafe.Pointer, bool
    var v V
    if ok {
        v = *(*V)(pv)
    }
}

```

```go
// 3. m["k"] = goo1
{
    pk := unsafe.Pointer(&"k")
    t := getMapType(m)
    h := getHmap(m)

    pv := mapassign(t, h, pk) // unsafe.Pointer на место под value
    *(*V)(pv) = goo1
}

```

```go
// 4. delete(m, "k")
{
    pk := unsafe.Pointer(&"k")
    t := getMapType(m)
    h := getHmap(m)

    mapdelete(t, h, pk)
}


```


### Структура мапы(схематично) 

![[Pasted image 20260104072145.png]]

**hash-seed** - рандомное число которое подмешивают для ключей мапы, для большей безопасности

#### LOB hash - low order bits

```
Hash(key) = 5461 (большое число мы делим на остатки его и этои будет номер бакета)
5461 % 4 = 1 
Hash(key) = 10101010101010101. 01 - по сути остаток отделения и он будет своотетствовать какому-либо бакету
2**n = buckets


```

Получаем из этого
```
LOB(hash) = 01
```

Более понятное объяснение:

```
ключ = "cat"
hash("cat") = 123456
123456 % 8 = 4
```
`cat` - лежит в бакете 4

внутри происходит:

1. `"cat"` → хэш-функция → `123456`
    
2. `123456 % 8 = 0`
    
3. идём **ТОЛЬКО** в бакет `0`
    
4. ищем `"cat"` внутри него
    
5. если нет → **ключа не существует**
## Структура бакета

![[Pasted image 20260104073124.png]]
Тут мы грубо говоря под разбиваем мапу на бакеты и ищем по бакетам вместо того чтобы искать просто в массе ключей. Если ключа нет в бакете, его нет в мапе. **В каждом бакете  8 значений**

На самом деле структура выглядит так:
![[Pasted image 20260104074500.png]]
в списке слева ключи. справа - значенияччч