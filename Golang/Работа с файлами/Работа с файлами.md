[[Работа с файлами(углублённо) 3]]
[[Работа с файлами (углублённо) 2]]
[[JSON в GO]]

## Запись файлов

```go
func main() {

    word := "Gazпром - one of the biggest tax payer company in Russia"

    b := []byte(word)

    err := os.WriteFile("Наш первый файл", b, 0666)

    if err != nil {
        log.Fatal(err.Error())
    }

}
```

Итак чтобы записывать что-то в файлы, нужно переписывать строку в байты. Os.writefile сам создаст необходимый нам файл, куда всё и попадёт. Ну и обработка ошибок по базе

## Чтение файлов

Тут мы поработали над весьма интересной в моём понимании задачей. Запарсили годовый отчёт МЮ на наличие определённых слов. 

```Go
package main

import (
	"fmt"
	"log"
	"os"
	"strings"
)

func main() {
	dat, err := os.ReadFile("Manchester United. Annual 2024 report..txt")

	if err != nil {
		log.Fatal(err.Error())
	}

	words := []string{"stadium", "transfer", "players", "fans", "UEFA", "Trafford"}

	for _, word := range words {
		wordCount := strings.Count(string(dat), word)
		fmt.Println("Слово", word, "встречается в годовом отчёте Manchester United:", wordCount, "раз.")
	}
}

```
Здесь оч интересная конструкция применяется а именно.

```go
wordCount := strings.Count(string(dat), word)
```

Короче, грубо говоря это строка очень удобно работает и не нужно в ручную делать счётчик для каждого слова. 
вот более просто пример позволяющий помочь нам понять что да как:
```go
strings.Count("hello hello", "lo") // → 2
	```


## Итоговый мини проектик(отчётность мю за 2024)

```go
	package main

import (
	"fmt"
	"log"
	"os"
	"strings"
)

func main() {
	dat, err := os.ReadFile("Manchester United. Annual 2024 report..txt")

	if err != nil {
		log.Fatal(err.Error())
	}

	words := []string{"stadium", "transfer", "players", "fans", "UEFA", "Trafford", "football", "global"}

	for _, word := range words {
		wordCount := strings.Count(string(dat), word)
		fmt.Println("Слово", word, "встречается в годовом отчёте Manchester United:", wordCount, "раз.")
	}

	result := []string{}

		strokes := strings.Split(string(dat), "\n")

	for i, stroke := range strokes {
		for _, word := range words {
			if strings.Contains(stroke, word) {
				result = append(result, fmt.Sprintf("%v, %s: %s\n", i+1, word, stroke))
			}
	}
	}
	
	resString := strings.Join(result, "\n")

	err = os.WriteFile("2024 MU Annual report", []byte(resString), 0644)
	
	if err != nil {
		log.Fatal(err.Error())
	}
}


```


## хуйня мною сделанная

[(_Let me know, let me know_)](https://genius.com/34764481/Tamar-braxton-let-me-know/Let-me-know-let-me-know)  
[Do you love the way I do when I'm lovin' your body?  
Hey, do you love the way I do when I'm lovin' your body?](https://genius.com/34639801/Tamar-braxton-let-me-know/Do-you-love-the-way-i-do-when-im-lovin-your-body-hey-do-you-love-the-way-i-do-when-im-lovin-your-body)  
When I'm lovin' your body, l-lovin' your body


```go
package main

import (
	"bufio"
	"fmt"
	"log"
	"os"
)

func main() {
	fmt.Println("Введите 3 задачи на день")

	file, err  := os.Create("todo.txt")

	if err != nil {
		log.Fatal(err.Error())
	}

	defer file.Close()

	for i := 0; i < 3; i++ {
		reader := bufio.NewReader(os.Stdin)
		fmt.Println("Введите одну из задач.")
		
		dailyTasks, _ := reader.ReadString('\n')
		
		_, err = file.WriteString(dailyTasks)

		if err != nil {
			log.Fatal(err.Error())
		}
	}
	todo, err := os.ReadFile("todo.txt")

	if err != nil {
		log.Fatal(err.Error())
	}

	fmt.Println("Спиоск задач:\n", string(todo)
}
```