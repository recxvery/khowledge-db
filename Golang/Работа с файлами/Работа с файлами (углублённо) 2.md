
## fmt.Scan() vs fmt.Scanln()/fmt.Println() vs fmt.Fprintln()
**Key dfifference**: функция без `F = flexible` в начале читают/записывают из/в `os.Stdout/osStdin` **ВСЕГДА**.
с `F` в начале, мы можем и читать и записывать из кастомных `reader'ов/writer'ов`

## **os.stdout**

На примере простого fmt.Println'a. Что у этой функции под капотом?
```go
func Fprintln(w io.Writer, a ...any) (n int, err error) {
	p := newPrinter()
	p.doPrintln(a)
	n, err = w.Write(p.buf)
	p.free()
	return
}

// Println formats using the default formats for its operands and writes to standard output.
// Spaces are always added between operands and a newline is appended.
// It returns the number of bytes written and any write error encountered.
func 	Println(a ...any) (n int, err error) {
	return Fprintln(os.Stdout, a...)
}

```
stdout - по сути writer, записывающий в терминал метаданные.

```go
var (
	Stdin  = NewFile(uintptr(syscall.Stdin), "/dev/stdin")
	Stdout = NewFile(uintptr(syscall.Stdout), "/dev/stdout")
	Stderr = NewFile(uintptr(syscall.Stderr), "/dev/stderr")
)
```
Здесь наглядно видим что **stdout** - по сути является файлом. **stdout - поток вывода.** Всё что мы печатаем в нём - выводится в терминале.  

**std.out** | **std.err** очень похожие между собой. По сути выводят одно и тоже разница лишь в том, что std.out(буферизуется, то есть выводится не сразу, а пачками), std.err(не буферизуется) и ошибки выводятся мгновенно.

По сути и то и другое нужно будет, когда уже изучим Kubernetees/Docker, потому что они берут логи из этих потоков

Типичная запись в файл. Это становится возможным потому что `file`. Имеет свой `io.Writer`(`file.Write()`) который вызывается.
```go
count, err = fmt.Fprintln(file, "hello\nworld")
```

## **os.stdin**

Стандартный ввод переменных  происходит через `fmt.Scan()`  Под капотом у нас следующая функция. `os.Stdin` - классический `io.Reader` 
```go
func Scan(a ...any) (n int, err error) {
	return Fscan(os.Stdin, a...)
}
```

Супер базовый кейс чтения из файла. `fmt.Fscanln` - читает до первого переноса строки.
```go
	file, err := os.Open("test.txt")
	if err != nil {
		log.Fatal(err)
	}
	defer func() {
		if err := file.Close(); err != nil {
			log.Fatal(err)
		}
	}()

	count, err = fmt.Fscanln(file, &text)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(text, text2, count)
```

## **os.Args** 

До жути простая переменная которая просто будет показывать все аргу2менты которые мы передаём через терминал
```go
func args() {
	for _, arg := range os.Args {
		fmt.Println(arg)
	}
}
```
Первым  всегда выводится название нашего файла. так что уместнее `os.Args[0:]`
```
cmd: 
go run main.go test test 2

output:
main.exe
test
test
2
```