
## **writeTo()**

`file.WriteTo()` - помогает нам экономить время и не создавать буфер, делать кастомный ридер, мы можем достать данные и записать их в какой угодно `io.Writer` удовлетворяющий интерфейсу `WriteTo()`

```go

func writeTo() {
	file, err := os.Open("test.txt")
	if err != nil {
		log.Fatal(err)
	}

	defer func() {
		if err = file.Close(); err != nil {
			log.Fatal(err)
		}
	} ()

	count, err := file.WriteTo(os.Stdout)
	if err != nil {
		log.Fatal(err)
	}

	fmt.Println(count)
}

```

## readFrom()
 `file.ReadFrom(file2)` - по сути читает данные из одного файла и попросту записывает их в другой. Тут всё очень просто.  Если что `file` - файл куда нам нужно завести данные а `file2` - откуда мы берём их

```go
  func readFrom() {
	file, err := os.Create("test2.txt")
	if err != nil {
		log.Fatal(err)
	}
	
	
	defer func() {
		if err := file.Close(); err != nil {
			log.Fatal(err)
		}
	} ()

	file2, err := os.Open("test.txt")
	if err != nil {
		log.Fatal(err)
	}
	
	
	defer func() {
		if err := file2.Close(); err != nil {
			log.Fatal(err)
		}
	} () 

	count, err := file.ReadFrom(file2)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println(count)
}

```

## **writeTo() vs readFrom()**

| WriteTo()                         | Readfrom()                         |
| --------------------------------- | ---------------------------------- |
| записывает из файла в другой файл | записывает в файл из другого файла |
| из --- в --- итог                 | в файл --- из --- итог             |
## **io.Copy()**

Эта замена обоим методам выше
```go
func IoCopy() {
	file, err := os.Open("test.txt")
	if err != nil {
		log.Fatal(err)
	}

	defer func() {
		if err := file.Close(); err != nil {
			log.Fatal(err)
		}
	} ()

	count, err := io.Copy(os.Stdout, file)
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println()
	fmt.Println(count)
}

```

Интерфейс под капотом - `dst` - destination, `src` - source 

```go
func Copy(dst Writer, src Reader) (written int64, err error) {
	return copyBuffer(dst, src, nil)
}
```

### io.copyBuffer()
Используется тогда когда у нас высоконагруженный софт. В нём мы можем редактировать буфер. Пример:
```go
	count, err := io.CopyBuffer(os.Stdout, file, make([]byte, 1))

```
**P.S** - в данном случае произойдёт очень много операций так как код мы будем читать побайтово, насколько я понял дефолтный размер буфера для этой функции (`size := 32 * 1024`)

Под капотом в copyBuffer() - т.е. он проверяет реализуются ли и `WriteTo()` и `ReadFrom()`
```go
	// If the reader has a WriteTo method, use it to do the copy.
	// Avoids an allocation and a copy.
	if wt, ok := src.(WriterTo); ok {
		return wt.WriteTo(dst)
	}
	// Similarly, if the writer has a ReadFrom method, use it to do the copy.
	if rf, ok := dst.(ReaderFrom); ok {
		return rf.ReadFrom(src)
	}
```


## **createFileBuffio() vs createFile()** 

Разница в скорости привычная, в первом случае создаём файл вносим туда значения с помощью `bufio`, во втором без

#### С `bufio`:

```go
func createFIleBuffio() {
	start := time.Now()
	defer func() {
		fmt.Println(time.Since(start))
	}()

	file, err := os.Create("test3.txt")
	if err != nil {
		log.Fatal(err)
	}

	defer func() {
		if err := file.Close(); err != nil {
			log.Fatal(err)
		}
	}()

	writer := bufio.NewWriter(file)
	defer func() {
		if err := writer.Flush(); err != nil {
			log.Fatal(err)
		}
	}()
	var i int

	for i < 100 {
		if _, err = writer.WriteString(fmt.Sprintf("%d\n", i)); err != nil {
			log.Fatal(err)
		}
	i++
	}
}

//result: 1.0074ms
```

#### Без `bufio`

```go
func createFIle() {
	start := time.Now()

	file, err := os.Create("test.txt")
	if err != nil {
		log.Fatal(err)
	}

	var i int

	for i < 100 {
		if _, err := file.WriteString(fmt.Sprintf("%d\n", i)); err != nil {
			log.Fatal(err)
		}

		i++
	}
	if err = file.Close(); err != nil {
		log.Fatal(err)
	}
	fmt.Println(time.Since(start))
}

//result : 2.2555ms
```

### **Почему такая разница?**

Если залезть по глубже в `WriteString()` без `bufio`

```go
return syscall.WriteFile(o.fd.Sysfd, unsafe.Slice(o.buf.Buf, o.buf.Len), &o.qty, o.overlapped())
```
Чтобы записать в файл грубо говоря 100 строк нам понадобится 100 системных вызовов `syscall`

С `bufio` уже по другому дела обстоят
```go
func NewWriter(w io.Writer) *Writer {
	return NewWriterSize(w, defaultBufSize) //defaultBufSize == 4096.
}
//то есть здесь создаётся какой то буфер. Все записи у нас хранятся в оперативной памяти на момент исполнения программы. Записали мы в этот буфер 290 байтов. Мы храним эти байты в буфере. Мы их никуда не записываем пока в файл.
```

Чтобы записать эти байты в файл у нас в коде есть
```go
		if err := writer.Flush(); err != nil {
			log.Fatal(err)
		}
```

`writer.Flush()` - сбрасывает данные с оперативной памяти на диск. Таким образом у нас всего один системный вызов(`syscall`) будет. А не 290

Это быстрее, **но занимает больше оперативной памяти**

> **Пакет `buf` позволяет сократить время выполнения программы за счёт потребления большего количества памяти**

