[[Ввод-Вывод, строки]]
[[package-variables-data types]]
[[Циклы]]


Набор переменных, логически объединённых в сущность, над которыми можно проводить разные действия.

## Объявление структур и способы инциализации

```go
package main  
  
type Data struct {  
    X int  
    Y int  
}  
  
func main() {  
    data1 := Data{10, 20}  
    _ = data1  
  
    data2 := Data{X: 10, Y: 20}  
    _ = data2  
  
     data3 := &Data{}  
    _ = data3  
}
```

## Способы объявления методов

```go
package main

type Data struct {
}

func (d Data) Print() {

}

func main() {
	var value1 = Data{}
	value1.Print()

	//1st way
	var value2WithSugar = &Data{}
	value2WithSugar.Print()

	//2nd way
	var value2WithoutSugar = new(Data)
	(*value2WithoutSugar).Print()
}
```

---
Забавная фишка в ГО существуют пустые методы которые нельзя вызвать. Неясно где они используются:
![[Pasted image 20250831150203.png]]


![[Pasted image 20250629152954.png]]
Короче, как я понял это по сути то же самое, что и словари в питоне

Короче тут есть очень интересная штука, как нам делать методы в ГОшке связанные со структурами. Нужны они нам из-за того что функций может быть миллион ещё и в разных файлах и короче фигнюшка получится. Метод это просто по сути синтаксический сахар для структуры.

## Pointer-reciever vs Value-reciever

Методы делаются вот так:

```go
func (u User) greeting() { //обрати внимание именно на эту строку
//пишем (u user) до имени функци
	fmt.Println("Bсем привет я", u.Name)
	fmt.Println("Мой MMR:", u.Rating)

	u.Rating = 1.0
}

```

Таким образом получаем потом:
![[Pasted image 20250629154437.png]]

И синтаксис уже вот такой вот: 
```go
    user.greeting()
    user.Goodbye()
```

А не такой:
```go
	greeting(user)
	Goodbye(user)
```


Юзая указатели: 
```go
func RatingUP(u *User, rating float64) {
	if u.Rating + rating <= 10.0 {
		u.Rating += rating
		fmt.Println("Я добавил рейтинг")
	} else {
		fmt.Println("Я не прошёл валидацию")
	}
}

func main() {
	user := User{
		Name:   "Вася",
		Rating: 4.3,
	}

	ptr := &user
	
	RatingUP(ptr, 4.9) //{Вася 9.2}
}
```
То есть нам здесь даже не надо разыменовывать что-либо. Как только мы передаём структуру как указатель, всё происходит само по себе.

И реализация с указателями через методы:
```go
func (u *User) RatingUP(rating float64) {
	if u.Rating + rating <= 10.0 {
		u.Rating += rating
		fmt.Println("Я добавил рейтинг")
	} else {
		fmt.Println("Я не прошёл валидацию")
	}
}

func main() {
	user := User{
		Name:   "Вася",
		Rating: 4.3,
	}

    user.RatingUP(4.9) //{Вася 9.2}
}
```
То есть здесь вообще всё само работает и даже не надо указатель создавать.

Вот эта вещь называется - **receiver**. Или же указатель на объект или объект структуры - как удобнее.

![[Pasted image 20250629160945.png]]

Reciever'ов есть два. Ресивер копии который мы использовали до этого и ресивер по указателю. Если нам не требуется изменять исходную структуру то используем ресивер копии, если меняем то по указателю.  Грубо говоря если мы принимаем в функции ресивер по значению то изменяться будет копия внутри метода, а не объект. В случае с указателем, учитывая что ресивер по указателю указывает адрес на наш изначальный объект меняется как раз объект. Грубо говоря:

```go
type customer1 struct {
	balance int
}

func (c customer1) add(value int) {
	c.balance += value
}

type customer2 struct {
	balance int
}

func (c *customer2) add(value int) {
	c.balance += value
}

func main() {
	c1 := customer1{}
	c1.add(100)

	c2 := customer2{}
	c2.add(100)

	fmt.Println(c1) //0
	fmt.Println(c2)//100
}

```

## Когда использовать одно и когда другое?

**Получатель ДОЛЖЕН быть указателем:**
	- Получатель должен быть указателем если метод должен изменить получателя
	- Если в получателе есть поле, которое нельзя копировать(прим. - тип из пакета sync)

**Получателю СЛЕДУЕТ быть указателем:**
	- Если получатель большой объект(чтобы его не копировать - размер объекта нужно бенчмаркать)

**Получатель ДОЛЖЕН быть значением**:
	-  Если нам не нужно менять получателя(нужно обеспечить его неизменяемость)

**Получателю СЛЕДУЕТ быть значением**:
	-  Если получатель является базовым типом(int, string, float64, etc)
	- Если изменяемые поля не являются частью структуры напрямую, а находятся внутри другой структуры

То есть вот нормальное объяснение для последнего пункта 
```go
package main

import "fmt"

type account struct {
	balance int
}

type client struct {
	account *account
}

func (c client) add(value int) {
	c.account.balance += value
}

func main() {
	c := client{
		account: &account{},
												}

	c.add(100)
	c.add(100)
	fmt.Println(c.account.balance) //200
}
```
Здесь меняется объект из-за DeepCopy, да мы копируем объект(client), но внутри него всё та же ссылка на указатель **account**

**По умолчанию, лучше всего выбирать Ресивер в виде значения, если нет причин не делать этого, но если возникают сомнения то использовать указатель**

```go
package main

import "fmt"

type Data struct {
	value int
}

func (d Data) Value1() int {
	return d.value
}

func (d *Data) Value2() int {
	return d.value
}

func main() {
	data := Data{100}
	pointer := &data

	value1ByData := data.Value1
	value1ByPointer := pointer.Value1 // == (*pointer).Value1. во втором случае синтаксический сахарок. можно разименовать и так
	// все равно всё это передаётся в копию и что есть указатель что его нет. Итог один - меняется копия объекта
	//А не он сам. Как гарица нихуяп не меняется забинженное значение даже если мы производим последующее изменение.

	value2ByData := data.Value2
	value2ByPointer := data.Value2

	data.value = 200
	fmt.Println("value1bydata:", value1ByData())
	fmt.Println("pointer1bydata:", value1ByPointer())
	fmt.Println("value1bydata:", value2ByData())
	fmt.Println("pointer2bydata:", value2ByPointer())
}

```

**Ещё одно важное правило или уже уточнение - смешивать ресиверы, не лучшая идея. То есть мы либо делаемся все ресиверы по значению, либо все по указателю.**

## Nil reciever

```go
package main  
  
import "fmt"  
  
type Obect struct{}  
  
func (o *Obect) Print() { // (o *Obect) = (Data).Print(data) = (*Data).Print(&data)  
    if o == nil {  
       fmt.Println("nil")  
    } else {  
       fmt.Println("Not nil")  
    }  
}  
  
func main() {  
    var object *Obect  
    object.Print()  
}
```
reciever - простой синтаксический сахар. На самом же деле это функция в которую первым аргументом передаётся объект

![[Pasted image 20250831175028.png]]


---
**Инкапсуляция** - один из основных принципов программирования, при котором мы скрываем от наших коллег(потребителей кода) конкретные детали реализации. Грубо говоря,они могут не переживать что сломают что-либо при изменении метода.


## Валидация структур

```go
func (u *User) changeName(newName string) {
	if len(newName) > 0 {
		u.Name = newName
	}
}

func (u *User) changeAge(newAge int) {
	if newAge > 0 && newAge < 150 {
		u.Age = newAge
	}
}

func (u *User) changePhone(newPhone string) {
	if len(newPhone) > 0 {
		u.PhoneNumber = newPhone
	}
}

func (u *User) closeAccount() {
	u.isClosed = true
}

func (u *User) openAccount() {
	u.isClosed = false
}
//то есть мы грубо говоря проверяем
```

Есть также конструктор структур:

```go

type User struct {
	//Имя пользователя не должно быть пустым
	Name        string

	//Возраст пользователя
	// Возраст должен быть больше нуля и меньше 150
	Age         int

	// Номер телефона
	// Номер телефона не должен быть пустым
	PhoneNumber string

	// Закрыт ли профиль пользователя
	isClosed    bool

	// Рейтинг пользователя
	// Правило: Рейтинг должен быть больше или равен нулю, но меньше или равен 10
	Rating      float64
}

func NewUser(
	Name string,
	PhoneNumber string,
	Age int, 
	isClosed bool, 
	Rating float64) User {
	fmt.Println("Валидирую имя")
	if Name == "" {
			fmt.Println("Валидиция не прошла (имя)")		
			return User {}
		}
	fmt.Println("Валидирую возраст")
	if Age <= 0 || Age > 150 {
			fmt.Println("Валидиция не прошла (возраст)")		
			return User {}
	}
	fmt.Println("Валидирую номер телефона")
	if len(PhoneNumber) == 0 {
			fmt.Println("Валидиция не прошла(номер телефона)")		
			return User {}
	}
	fmt.Println("Валидирую рейтинг")
	if Rating <= 0.0 || Rating > 10.0 {
			fmt.Println("Валидиция не прошла(рейтинг)")		
			return User {}
	}

	return User{
		Name: Name,
		Age: Age,
		PhoneNumber: PhoneNumber,
		isClosed: isClosed,
		Rating: Rating,
	}
}

func main() {
	user := NewUser(
		"Вова", 
		"89004752036",
		20,
		false,
		8.0,
	)
	fmt.Println(user.getAge())
	fmt.Println("User:", user)
}
```