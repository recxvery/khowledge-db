### Что такое канал?

Указатель на структуру, который является способом передачи информацией между горутинами.

**канал это концепция:**
- разделение на роли(читатели и писатели)
- любое количество участников в рамках одной роли![[Pasted image 20260128161745.png]]

- конкурентно безопасная передача из рук в руки![[Pasted image 20260128161818.png]]
- блокирующее ожидание при отсутствие одной из стороны
![[Pasted image 20260128161835.png]]
- очереди ожидания для читателей и писателей.
![[Pasted image 20260128161917.png]]

Теперь мысленно заменяем роботов на схеме на горутины.

Роли могут быть комбинированными

![[Pasted image 20260128162045.png]]

Но сама суть каналов не меняется, меняется лишь принцип работы комнаты.

**Всё это о каналах без буфера**


### С буфером

![[Pasted image 20260128162212.png]]

Все три робота что положили 3 кирпича не блокируются. а 4 заблочен будет

![[Pasted image 20260128162259.png]]

![[Pasted image 20260128162343.png]]

Примерно так работает **rate limiter**. Есть и другие варианты, но концепции у них похожи(worker pool, semaphore и т.д.)

**Каналы с буфером и каналы без буфера невзаимозаменяемы**

**Обычный канал используется только тогда, когда передача данных между данными - основная цель коммуникации.**

> «Я НЕ МОГУ продолжить работу, пока ты не забрал мои данные».

```go
ch := make(chan int)

go func() {
    ch <- 42
    fmt.Println("отправил")
}()

value := <-ch
fmt.Println("получил", value)

```

«Вот тебе число 42. Возьми его СЕЙЧАС, иначе я не иду дальше».

**Данные — это смысл.**

**Каналы с буфером используются, когда горутины передают друг другу служебную информацию об определённом ограничении**

**Использование канала с буфером только для передачи данных - возможно, но это лишний оверхэд(лишняя память - ячейки буфера, лишняя нагрузка на процессор - положить данные в буфер(копирование), а потом скопировать их оттуда) . Придётся писать более внимательный код, учитывать возможные потери данных(что делать если буфер забился) и т.д.**

### Буферизованные vs небуферизированные каналы.

Почему в небуферизованных каналах нет копирования в буффер, а потом копирования из буфер? Там используется **прямая передача из стека в стек (Direct Stack-to-Stack Copy)**.

- GO видит адрес переменной в стеке Горутины-получателя
- Он берёт значение из стека горутины-отправителя
- И копирует значения напрямую по адресу.
	В буферизованном канале всё иначе там есть посредник - структура данных самого канала(hchan), у которой есть массив(буфер) в куче `heap`.
- **Шаг 1:** Отправитель копирует данные из своего стека в **буфер канала**.

- **Шаг 2:** Получатель (когда придет время) копирует данные из **буфера канала** в свой стек.

| **Тип канала**       | **Оверхед по памяти**                       | **Оверхед по CPU**                   | **Главный риск**                               |
| -------------------- | ------------------------------------------- | ------------------------------------ | ---------------------------------------------- |
| **Небуферизованный** | Минимальный (только структура канала)       | Высокий (из-за переключений горутин) | Простой программы (Wait)                       |
| **Буферизованный**   | Зависит от размера буфера (массив в памяти) | Средний (копирование + мьютекс)      | Потеря "актуальности" данных и потребление RAM |

**Размер буфера = максимальное количество одновременно работающих горутин.**


> [!правило]
> «Мне не важно ТЕБЕ что-то передать.  
> Мне важно СОБЛЮСТИ ОГРАНИЧЕНИЕ»

Значение нам не так важно как ограничения:
- значение часто не важно
- важен сам факт *можно / нельзя / занято / свободно*
- канал = **счётчик** / **тормоз**

```go
limit := make(chan struct{}, 3)

for i := 0; i < 10; i++ {
    limit <- struct{}{} // ❗ может заблокироваться

    go func(i int) {
        defer func() { <-limit }()

        fmt.Println("работаю", i)
        time.Sleep(time.Second)
    }(i)
}
```

Канал — это счётчик занятых мест.  
Размер буфера — это лимит.  
Нет места — СТОП.

Вот сука максимально простая горутина на понимание:
```
go func() {
    ch <- 2 + 3
}()
```

```
main goroutine:
    ch := make(chan int)
    go ...
    result := <-ch   ← ждёт

worker goroutine:
    ch <- 5          ← отправляет
```


