Вспоминаем что значит слово аксиома и готовимся к тому что разработчики языка ничего не будут нам объяснять и мы обязаны будем додумывать что-либо сами.

## Аксиомы каналов

![[Pasted image 20260111160101.png]]

```go
	var ch chan int //nil channel
```
`nil` channel — это канал, который существует только как тип,  
но не связан ни с какой структурой данных.

Через make, мы всегда создаём открытый канал
```go
	ch := make(chan int)
```

Смотрим на 1 строчку, второй столбец. Это **Аксиома**
```go
func main() {
	ch := make(chan int)

	close(ch)
	//нельзя два раза закрывать канал
	close(ch) //panic: close of closed channel
}
```

Читаем значение из закрытого канала(2 cстрочка 2 столбец):
```go
	ch := make(chan int)

	close(ch)
	//нельзя два раза закрывать канал
	v := <-ch
	fmt.Println(v) //0 - defaultValue

```
Несмотря на то что канал закрыт мы можем читать его и делать это сколько угодно раз. **Аксиома**. Закрытие канала - сигнал о том что с каналом мы не работаем больше.

Тут есть флажок как и у `map'ы` где мы проверяем яв-ся ли записанное значение defaultValue или туда что-то да положили
```go
	ch := make(chan int)

	close(ch)
	//нельзя два раза закрывать канал
	v, ok1 := <-ch
	v1, ok2 := <-ch
	v2, ok3 := <-ch
	
	fmt.Println(v1, v2, v)
	fmt.Println("ok:", ok1, ok2, ok3)
```

Мы не можем записывать значения в закрытый канал(3 строчка 2 столбец):
```go
func main() {
	ch := make(chan int)

	close(ch)
	//кладём значение в закрытый канал
	ch <- 10 // panic: send on closed channel
}
```
**Аксиома**

Хороший пример для закрытия каналов. Мы будто итерируемся по каналу пока он не закрыт и можем ещё считать какие-то значения из него. Если мы не закроем его в горутине - будет **deadlock**. Если мы не знаем количество итераций. То это самый верняковый способ. Здесь мы его не знаем. Может быть 3 итерации, а может быть и 6 
```go
func main() {
	transferPoint := make(chan int)
	//miner
	go func() {
		iterations := 3 + rand.Intn(4)
		fmt.Println("Iterations:", iterations)
		for i := 0; i < iterations; i++ {
			transferPoint <- 10
			time.Sleep(300 * time.Millisecond)
		}

		close(transferPoint) //Закрытие канала
	}()

	coal := 0

	for v := range transferPoint {
		coal += v
		
		fmt.Println("coal:", coal)
	}

	fmt.Println("Суммарно добыто угля:", coal)
}
```

#### nil channel

Смотрим на 2ую и 3ью строку 1-ого столбца
```go
func main() {
	var ch chan string

	go func() {
		ch <- "Hello World" //канал блокирован при попытке что-то в него записать
	}()

	v := <-ch //канал блокирован при попытке что-то из него прочитать
	fmt.Println("v:", v)

	// close(ch)
}
```
#### Вывод 
Лучше всего не использовать неицилиазированные каналы(**nil channel**). И всегда инициализировать каналы, т.к. мы не можем nil-каналы закрыть,, мы не можем читать или записывать в них что-то в ином случае мы ловим **deadlock**

❗ `nil` каналы не используют для передачи данных.  Они используются только как управляющий механизм.