z**Горутины - операции, которые могут выполняться параллельно вне зависимости от функции, в которой они запущены. Главная особенность горутин в том что они выполняются параллельно**


**goroutine** - функция которая может запускаться конкурентно

**Порядок горутин нам никогда не гарантирован**.
**Если логика программы зависит от порядка выполнения горутин — программа сломана**

В этом примере они выведутся в абсолютно рандомном порядке.

```go
 func main() {
	meters := 0

	initTime := time.Now()

	go run(1)
	go run(2)
	go run(3)

	time.Sleep(5 * time.Second)
	fmt.Println("Игрок пробежал: ", meters, "метров")
	fmt.Println("Прошло времени:", time.Since(initTime))
}

```

Чтобы объявить горутину  - ключевое слово **go**

```go
	go run()
```

###### func main() - никогда не ждёт выполнения программ. Если она выполнилась раньше горутин, значит горутины не выведутся. Иначе мы бы вечно могли бы ждать выполнение горутины. И поэтому мы используем `time.Sleep()`. К слову он плох тем что наши горутины либо умирают до его выполнения, либо могут висеть слишком долго.

##### go run() vs f()

```
f() — выполнение здесь и сейчас
go f() — регистрация задачи у планировщика и немедленный возврат
```

#### Анонимные функции в горутинах

```go
func main() {
	go func() {
		for {
			fmt.Println("Hello World")

			time.Sleep(100 * time.Millisecond)
		}
	}()

	time.Sleep(1 * time.Second)
}

```

Есть фича на 4ёх ядерных процессорах от GO

![[Pasted image 20260111012855.png]]

Максимум может использоваться 4 процесса. Но как и в примере выше. Го суперэффективно использует эти 4 ядра. У нас есть time.sleep() как только один процесс встанет сразу же запустится другой. И так постоянно. Поэтому GO очень эффективный язык. Сколько ядер работают параллельно решает - **GOMAXPROCS**.

```
GOMAXPROCS = количество логических ядер CPU
```

### Каналы(chan int)

Каналы - средство коммуникации между горутинами.

```
chan тип_элемента
```

для его инициализации:

```go
var intCh chan int = make(chan int) // канал для данных типа int
 
fmt.Println(intCh) // 0xc000100070

```

### Блокировка писателей и читателей

|Ситуация|Кто блокируется|
|---|---|
|Чтение из пустого канала|читатель|
|Запись в полный буфер|писатель|
|Небуферизированный канал, нет читателя|писатель|
|Небуферизированный канал, нет писателя|читатель|

### Буферизированные каналы vs небуферизированные

Рассмотрим на этом примере:

```go
package main

import (
	"fmt"
	"time"
)

//Функция описывающего поход рабочего в шахту
//принимает номер похода в шазту
//возвращает Добытый уголь

func run(countPoint chan int, n int)  {
	fmt.Println("Забегание игрока по флангу номер", n, "началось")
	time.Sleep(2 * time.Second)
	fmt.Println("Забегание игрока номер", n, "закончено")

	countPoint <- 40 //передаем в канал
	fmt.Println("Игрок под номером", n, "забежал")
}

func main() {
	meters := 0

	countPoint := make(chan int)

	initTime := time.Now()

	go run(countPoint, 14)
	go run(countPoint, 9)
	go run(countPoint, 10)

	meters += <- countPoint
	time.Sleep(3 * time.Second)

	meters += <- countPoint
	time.Sleep(3 * time.Second)

	meters += <- countPoint
	time.Sleep(3 * time.Second)
	



	fmt.Println("Игроки пробежали: ", meters, "метров")
	fmt.Println("Прошло времени:", time.Since(initTime))
}

```

**Наглядно - небуфиризированный канал:**![[Pasted image 20260111014149.png]]
Грубо говоря мы считаем постепенно, но при этом на фоне горутины выполняются. И мы ждем когда же мы уже посчитаем игрока под номер 10 и 9.

Мы всегда блокируемся(код останавливается) пока не прочитаем из небуфиризированного канала что-либо. С обратной стороны это работает точно также, пока мы не прочитаем - канал мы блокируемся.

Небуферизированный канал это грубо говоря рукопожатие. Отправитель не может отправить, пока получатель занят и наоборот.

**Буферизованный:**

```go
	countPoint := make(chan int, 3) //выделяем 3 ячейки под буфер
```

![[Pasted image 20260111014924.png]]

Буферизованный лучше использовать тогда когда у нас дальше есть какая-либо осмысленная логика:

```go
func run(countPoint chan int, n int)  {
	fmt.Println("Забегание игрока по флангу номер", n, "началось")
	time.Sleep(2 * time.Second) 
	fmt.Println("Забегание игрока номер", n, "закончено")

	countPoint <- 40 //передаем в канал
	fmt.Println("Игрок под номером", n, "забежал")
	
	//...ещё множество каких-либо операций
}

```

Ни один из них не лучше и не хуже другого, нужно думать когда стоит использовать один, а когда нет.

Также если допустим мы сынициазировали - 2 канала. А по сути работает 3. То после того как освободиться ячейка в буфере всё идет так как при небуферизированном канале(читатель блокируется или тот кто записывает)

При чтении из буферезированного канала, читатель блокируется, если буфер пуст. А кто записывает блокируется только тогда когда в буфере нет места. И это одно из ключевых отличий

Если у нас 3 канала, а мы читаем 4 раза - произойдёт **deadlock**(). Наша главная горутина(main-gorotuine) остановиться на всегда в ожидании чтения из канала которого не существует. Соответственно поток кода остановиться. Нужно следить за тем чтобы не попадать в **deadlock**. 

**Утечка горутин** - посути обратная **deadlock'y** ситуация, когда мы прочитали допустим 3 раза, а каналов у нас 100. Соответственно эти горутины будут постоянно выполняться и обрабатываться процессором на фоне, что будет сильно замедлять производительность кода. Это не так смертельно, как deadlock, но тоже плохо. Грубо говоря **утечка горутин** - горутины живут вечно и не исчезают. Словно оставить свет включенным в 1000 комнатах.

#### Наглядная демонстрация необходимости горутин:

![[Pasted image 20260111020406.png]]

Без горутин мы УСЛОВНО будем проходить циклом по слайсу сообщений. Обрабатываем их ну допустим за секунду. И так если у нас будет 5 000 пользователей, то последний последовательный пользователь будет 5000 секунд ждать отправку сообщения - полный бред. Так что, вместо этого используем горутины и за секунду мы ГРУБО ГОВОРЯ обработаем 5000 сообщений сразу.

К слову про процессоры и как вообще горутины стали возможны? Возможными они стали только тогда, когда появились многоядерные процессоры

![[Pasted image 20260111020649.png]]

Каждое ядро это прям ГРУБО ГРУБО ГОВОРЯ, процессор внутри процессора, каждое ядро берет под себя отдельную задачу. Отсюда и появилась возможность параллельных программ.

**ДЗ**

Условие первого домашнего задания по теме "Горутины и каналы"

- Опишите функцию, которая принимает целое число (свой номер), после чего 5 раз, с интервалом в одну секунду, выводит на экран:
- "Я горутина N, делаю вывод на экран в X раз", где N номер горутины, а Х - номер итерации
- Запустите 3 горутины, в каждой горутине запущена вышеописанная функция - Посмотрите на вывод в консоли, объясните себе его, оцените, насколько этот Вывод соответсвует вашим ожиданиям

```go
func priteration(n int) {
	for i := 0; i < 5; i++ {
		fmt.Printf("Я горутина %v, делаю вывод на экран в %v раз.\n", n, i)
	}
}

func main() {
	go priteration(1)
	go priteration(2)
	go priteration(3)

	time.Sleep(1 * time.Second)
}

```

Вывод:

```
Я горутина 3, делаю вывод на экран в 0 раз.
Я горутина 3, делаю вывод на экран в 1 раз.
Я горутина 3, делаю вывод на экран в 2 раз.
Я горутина 3, делаю вывод на экран в 3 раз.
Я горутина 3, делаю вывод на экран в 4 раз.
Я горутина 2, делаю вывод на экран в 0 раз.
Я горутина 2, делаю вывод на экран в 1 раз.
Я горутина 2, делаю вывод на экран в 2 раз.
Я горутина 2, делаю вывод на экран в 3 раз.
Я горутина 2, делаю вывод на экран в 4 раз.
Я горутина 1, делаю вывод на экран в 0 раз.
Я горутина 1, делаю вывод на экран в 1 раз.
Я горутина 1, делаю вывод на экран в 2 раз.
Я горутина 1, делаю вывод на экран в 3 раз.
Я горутина 1, делаю вывод на экран в 4 раз.
```

В принципе ничего необычного тут нет. Горутины выполняются в неупорядоченном порядке. Я ожидал нечто подобного. Даже и распинаться не о чем особо

#### Ещё одно отличие буферизованных каналов и небуферизованных

Этот код сработает

```go
func main() {
	ch := make(chan int, 1)

	ch <- 1

	v := <- ch
	fmt.Println(v)
}

```

Этот нет: 

```go
func main() {
	ch := make(chan int)

	ch <- 1

	v := <- ch
	fmt.Println(v)
}

```
Так как у нас блокируется читатель во втором случае.