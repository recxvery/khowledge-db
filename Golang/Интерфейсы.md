
**Интерфейсы** - абстрактный тип, способный на добавление методов к разным структурам. Грубо говоря, это своего рода фильтр. Который определяет что должны уметь делать объекты(при этом он не отвечает за реализацию их методов). Говоря грубо, пример с розеткой. Ей все равно что мы в неё втыкаем, главное это вилка.

**Официальное понятие** - специальный тип данных в GO, представляющий из себя набор сигнатур методов, которые нужно реализовать его имплементации.(Грубо структура должна реализовать методы интерфейса) 

**Имплементация интерфейса = когда наш конкретный тип реализует все методы указанные в в интерфейсе**. Явной имплементации в го нету. Поэтому тут скорее дело в утиной типизации(duck typing) + статической типизации. То есть то что бегает, плавает, летает, крякает = утка. И проверяется так это или нет на этапе компиляции программы, что отличается от классического duck typing в любом другом языке. Грубо говоря, чтобы имплементировать интерфейс. нужно просто реализовать все его методы.

**Утиная типизация (duck typing**) — это принцип в программировании, согласно которому тип объекта определяется не его классом, а поведением

#### Объявление интерфейсов

```go
package main

type Runner interface {
	Run() string
}

type Swimmer interface {
	Swim() string
}

type Flyer interface {
	Fly() string
}
```
### Описание структуры интерфейса

```go
type iface struct {
	tab  *itab          // это указатель на Interface Table или itable - структуру, которая хранит некоторые метаданные о типе и список методов, используемых для удовлетворения интерфейса. 
	data unsafe.Pointer // хранимые данные (указатель на значение)
}
```

- **itab** - помогает GO понять какие методы доступны для каждого интерфейсного значения и как их применять.  Грубо говоря через него смотрим какие методы есть у типа данных и куда в памяти обратиться чтобы эти методы нам вызвать. 

- **data.unsafe.Pointer** - Указатель на конкретные данные или значения. **unsafe.Pointer** - указывает на хранимое значение, при этом сохраняя информацию о том как к ним обращаться через **itab**

То есть грубо говоря **itab** - узнаёт о том какие методы нам вызывать для данного типа данных, **data** - предоставляет эти самые данные для вызова метода

##### Ещё есть etab(структура для пустого интерфейса)

```go
type eface struct {
    _type *_type         // тип конкретного значения
    data  unsafe.Pointer // данные
}
```
Тут нету у нас массивов метода и прочего так как они у нас не заданы

#### Cтруктура itab

```go
type itab struct {       // 40 bytes on a 64bit arch
	inter *interfacetype // тип интерфейса
	_type *_type         // все, что мы знаем про тип из которого образован элемент интерфейса
	hash  uint32         // copy of _type.hash. Used for type switches.
	_     [4]byte
	fun   [1]uintptr     // методы, которые должна описывать структура, чтобы релизовывать интерфейс
}
```
- **`inter`** -  Метаданные интерфейса
- `_type *_type ` - указатель на информацию которую содержит интерфейс
- `hash uint32` - хэш типа который помогает нам проводить различные операции с интерфейсом(type switches)
- `fun` - содержит массив функций(которые являются методами) которые нужно реализовать для удовлетворения интерфейса

#### Иллюстрация хранения значений интерфейса

```go
package main

import (
	"fmt"
	"strconv"
)

type Binary uint64

func (i Binary) String() string {
	return strconv.FormatUint(i.Get(), 2)
}

func (i Binary) Get() uint64 {
	return uint64(i)
}
func main() {
	b := Binary(64)
	fmt.Printf("Type: %T Value %v\n", b, b)
}
```

![[Pasted image 20251123203810.png]]

Что здесь происходит? `itab` - подбирает методы интерфейса в массиве которые нужно реализовать(String(), Get() в данном коде). А  также тип данных который будет использоваться. В `data` же у нас хранится значение - 200
```go
fmt.Printf("Type: %T Value %v\n", b, b)
//Type: main.Binary Value 1000000
```

##### Популярная на собесах задача

```go
func main() {
	var ptr *struct{}
	var iface interface{}
	iface = ptr
	if iface == nil {
		println("It's nil!")
	}
} //nil - не вывдеется так как интерфейс не пустой
```

 #### Состав интерфейса

![[Pasted image 20251105195830.png]]
3 стадии интерфейсного значения. 

1 - пустой интерфейс(нету типа данных, нету значения).
2 - непустой интерфейс(есть тип данных, нету значения).
3 - есть и значение и тип данных

**Интерфейсы поддерживают встраивание, так что можно поступить вот так:**
```go 
type Ducker interface {
	Runner
	Swimmer
	Flyer
}
```

```go
func main() {
	interfaceValues()
}

func interfaceValues() {
	var runner Runner // default value - nil
	fmt.Printf("Type: %T Value: %v\n", runner, runner)//Type: <nil> Value: <nil>
	
	if runner == nil {
		fmt.Println("Runner is nil")
	}
	
	//runner = int64(1) 
	// cannot use int64(1) (constant 1 of type int64)
	//  as Runner value in assignment: int64 does not implement Runner (missing method Run)
}
```
Если у интерфейса нет конкретного значения и конкретного типа он равен нулю. А также что будет если попробуем встроить интерфейс который не  будет поддерживать необходимые нам методы.

> Интерфейс равен nil только если _оба поля_ равны nil: tab == nil и data == nil.


```go
	var unnamedRunner *Human
	fmt.Printf("Type: %T Value: %v\n", unnamedRunner, unnamedRunner) //Type: *main.Human Value: <nil> Здесь мы объявили переменную с указателем на знакомый
	//тип данных Human

	runner = unnamedRunner
	fmt.Printf("Type: %T Value: %v\n", runner, runner) //Type: *main.Human Value: <nil>

	if runner == nil {
		fmt.Println("Runner is nil")//В случае вызова метода здесь будет паника
	}
```
Вот здесь очень важный поинт, который еще и на собесах любят поспрашивать.  В чём тут весь смысл? Мы создаём nil pointer. И интерфейс уже не пустой. То есть у него уже есть значение - тип данных.  Наше условие сработает, он содержит **ConcreteType**(main.human), но при этом из-за того что проверка сработает могут быть потом большие проблемы с тем, что у нас не сработает наш метод. То есть интерфейс как бы не пуст и дойдёт до метода, но при этом возникнет паника(из-за того что структура пустая). Если посмотреть на состав интерфейса, он будет пустым только при условии если тип данных неизвестен и в значении nil.

```go
	namedRunner := &Human{Name: "Jack"}
	runner = namedRunner
	runner.Run() //в данном случае всё будет окей
```

```go

	runner = unnamedRunner
	fmt.Printf("Type: %T Values: %v\n", runner, runner)	
	if runner == nil {
		fmt.Println("Runner is nil")
	}

	runner.Run() //panic: value method main.Human.Run called using nil *Human pointer
```
То есть даже если мы знаем тип данных интерфейса, но он не содержит конкретного значения будет **паника**

```go
	namedRunner := &Human{"Джек"}
	fmt.Printf("Type: %T Value: %v\n", namedRunner, namedRunner)

	runner = namedRunner	
	fmt.Printf("Type: %T Value: %v\n", runner, runner) //Type: *main.Human Value: &{Джек}
```

### Пустой интерфейс

не содержит методов в себе

```go
	var emptyInteface interface{} = unnamedRunner
	fmt.Printf("Type: %T Values: %v\n", emptyInteface, emptyInteface) //Type: *main.Human Values: <nil>

	emptyInteface = 1
	fmt.Printf("Type: %T Values: %v\n", emptyInteface, emptyInteface) //Type: int Values: 1

	emptyInteface = "Empty Interface"
	fmt.Printf("Type: %T Values: %v\n", emptyInteface, emptyInteface) //Type: string Values: Empty Interface

	emptyInteface = true
	fmt.Printf("Type: %T Values: %v\n", emptyInteface, emptyInteface) // Type: bool Values: true


	emptyInteface = &Human{}
	fmt.Printf("Type: %T Values: %v\n", emptyInteface, emptyInteface) // Type: *main.Human Values: &{}
```

**Пример пустого интерфейса функция - fmt.Print**

![[Pasted image 20251123192915.png]]

Для чего он нужен?

Можем хранить любой тип данных в массиве с помощью него. То есть то что считается списками в массиве здесь реализуется через пустой интерфейс:

```go
	anyTypeCollection := []interface{}{1, "DONDA", true}
	fmt.Printf("Type: %T Values: %v\n", anyTypeCollection, anyTypeCollection) //Type: []interface {} Values: [1 DONDA true]
```

Ну и как в случае с fmt.Printf. Можем получать любые значения на вход в функцию.

```go
func Log(v interface{}) {
    fmt.Println("LOG:", v)
}
```

### Полиморфизм

```go

func typeAssertionAndPolymorphism() {
	var runner Runner
	fmt.Printf("Type %T Value %v\n", runner, runner)

	Usayne := &Human{Name: "Usayne"}
	runner = Usayne
	polymorphism(runner)

	Donald := &Duck{Name: "Donald", Surname: "Duck"}
	duck := Donald
	polymorphism(duck)
}

func polymorphism(runner Runner) {
	fmt.Println(runner.Run())
}

```
Здесь происходит наглядная демонстрация принципа полиморфизма - у нас есть общая сигнатура(метод Run()), но реализация будет разная в первом случае - у нас будет вывод
`Человек бежит` во втором `Duck is running` 

### Type Assertion

Он нам  нужен для получения конкретного типа данных и реализации конкретных методов. Через него мы можем получать конкретный тип данных содержащийся в интерфейсах не зная какой тип данных в нём находится и **ИСПОЛЬЗОВАТЬ МЕТОДЫ КОТОРЫЕ НЕ ОБЪЯВЛЕНЫ В ИНТЕРФЕЙСЕ**.

```go
func typeAssertion(runner Runner) {
	fmt.Printf("Type: %T Value: %v\n", runner, runner)
	if hman, ok := runner.(*Human); ok { //пытаемся у интерфейсного значения получить конкертный тип, если он совпадает то мы получаем
		//ConcreteValue Грубо говоря мы пытаеся получить от интерфейса значение ConctereData - Human, если получится
		//то мы получаем ConcreteValue который переносится в переменную hman
		fmt.Printf("Type: %T Value: %v\n", hman, hman)
		fmt.Println(hman.writeCode()) //здесь имеем значение конкретного типа сюда же передаётся указатель в таком случае спокойно можем использовать
		//методы со структуры Human
	}

	if duck, ok := runner.(*Duck); ok {
		fmt.Printf("Type: %T Value: %v\n", duck, duck)
		fmt.Println(duck.Fly())
	}

	//Более короткая запись typeAssetrion
	switch v := runner.(type) { //также получаем тип данных в переменную V
	case *Human:
		fmt.Println(v.writeCode())
	case *Duck:
		fmt.Println(v.Fly())
	default:
		fmt.Printf("Type: %T Value: %v\n", v, v)
	}
}
```
#### Простейший пример

```go
package main

import "fmt"

type Hero interface {
	Blink()
	Ultimate()
}

type Am struct {
}

type Earthshaker struct {
}

type PaAssasin struct {

}

func (h Am) Blink() {
	fmt.Println("Я антимаг в доте. Я нажал блинк в лес и дальше пошёл бить крипов")
}

func (e Earthshaker) Blink() {
	fmt.Println("Я шейкер. Я нажал блинк в рошпит и сделал рампагу")
}

func(p PaAssasin) Blink() {
	fmt.Println("Я фантомка. Я блинканулась на противника и убила его с трех ударов.")
}
 
func(p PaAssasin) Ultimate() {
	fmt.Println("Мой ультимейт(пассивная способность сработал) и я зафармила кемп с одного удара")
}

func farm(h Hero) {
	fmt.Println("Я играю на герое")
	fmt.Println("Я бью крипов")
	h.Blink()
	h.Ultimate()
}

func main() {
	// antiMage := Am{}
	pa := PaAssasin{}

	farm(pa)
}

```
Для чего здесь интерфейсы? Видим три разных структуры(наши герои в доте), и без интерфейса(в который мы вложили необходимые методы), нам бы пришлось три раза определять функции с одним и тем же кодом по сути:
farm(a AM), farm(e Earthshaker)... То есть это дублирование кода, при чем в нашем коде это в наименьшем объёме, а ведь функции могут быть на 200 строк и что тогда будет с кодом?

Интерфейсы помогают нам использовать функцию полиморфиза(один раз написали функцию и теперь используем её везде )


Легкий оффтопчик. Разница в прохождении элементов по map'е и slice'ам:
```go
package main

import (
	"fmt"
	"strconv"
	"time"
)

type PaymentInfo struct {
	ID          int
	Description string
	USD         int
	isCancelled bool
}

type PaymentModuleWithSlice struct {
	s []PaymentInfo
}

func (m *PaymentModuleWithSlice) AddInfo(info PaymentInfo) {
	m.s = append(m.s, info)
}

func (m PaymentModuleWithSlice) FindInfo(ID int) PaymentInfo {
	for _, info := range m.s {
		if info.ID == ID {
			return info
		}
	}

	return PaymentInfo{}
}

//---------------------------------

type PaymentMethodWithMap struct {
	m map[int]PaymentInfo
}

func (a *PaymentMethodWithMap) AddInfo(info PaymentInfo) {
	a.m[info.ID] = info
}

func (a PaymentMethodWithMap) FindInfo(ID int) PaymentInfo {
	s, ok := a.m[ID]
	if ok {
		return s
	}

	return PaymentInfo{}
}

func main() {

	pSlice := PaymentModuleWithSlice{}
	pMap := PaymentMethodWithMap{
		m: make(map[int]PaymentInfo),
	}

	
	//-----------------------------------------------------
	
	iterations := 200_000
	
	b4 := time.Now()

	for i := 0; i < iterations; i++ {
		info := PaymentInfo{
			ID:          i,
			Description: strconv.Itoa(i),
			USD:         i + i,
			isCancelled: false,
		}

		pMap.AddInfo(info)
	}

	fmt.Println("Map Add:", time.Since(b4))

	b4 = time.Now()

	for i := 0; i < iterations; i++ {
		info := PaymentInfo{
			ID:          i,
			Description: strconv.Itoa(i),
			USD:         i + i,
			isCancelled: false,
		}

		pSlice.AddInfo(info)
	}

	fmt.Println("Slice Add:", time.Since(b4))



//-------------------------------------------------------------------
	
	b4 = time.Now()

	for i := 0; i < iterations; i++ {
		info := pMap.FindInfo(i)
		_ = info
	}

	fmt.Println("Map Find:", time.Since(b4))

	b4 = time.Now()

	for i := 0; i < iterations; i++ {
		info :=  pSlice.FindInfo(i)

		_ = info
	}

	fmt.Println("Slice Info:", time.Since(b4))


	// info1 := PaymentInfo{
	// 	ID:          10,
	// 	Description: "IPhone 16 Pro",
	// 	USD:         900,
	// 	isCancelled: false,
	// }

	// pSlice.AddInfo(info1)
	// pMap.AddInfo(info1)

	// pp.Println("Slice", pSlice)
	// pp.Println("Map:", pMap)

	// i1 := pSlice.FindInfo(10)
	// i2 := pMap.FindInfo(10)

	// fmt.Println(i1)
	// fmt.Println(i2)
}

```
```
Map Add: 68.0945ms
Slice Add: 137.4435ms
Map Find: 34.4867ms
Slice Info: 57.3287436s
```