
**Интерфейсы** - абстрактный тип, способный на добавление методов к разным структурам. Грубо говоря, это своего рода сортировщик. Который определяет что должны уметь делать объекты(при этом он не отвечает за реализацию их методов). Говоря грубо, пример с розеткой. Ей все равно что мы в неё втыкаем, главное это вилка.

#### Простейший пример

```go
package main

import "fmt"

type Hero interface {
	Blink()
	Ultimate()
}

type Am struct {
}

type Earthshaker struct {
}

type PaAssasin struct {

}

func (h Am) Blink() {
	fmt.Println("Я антимаг в доте. Я нажал блинк в лес и дальше пошёл бить крипов")
}

func (e Earthshaker) Blink() {
	fmt.Println("Я шейкер. Я нажал блинк в рошпит и сделал рампагу")
}

func(p PaAssasin) Blink() {
	fmt.Println("Я фантомка. Я блинканулась на противника и убила его с трех ударов.")
}
 
func(p PaAssasin) Ultimate() {
	fmt.Println("Мой ультимейт(пассивная способность сработал) и я зафармила кемп с одного удара")
}

func farm(h Hero) {
	fmt.Println("Я играю на герое")
	fmt.Println("Я бью крипов")
	h.Blink()
	h.Ultimate()
}

func main() {
	// antiMage := Am{}
	pa := PaAssasin{}

	farm(pa)
}

```
Для чего здесь интерфейсы? Видим три разных структуры(наши герои в доте), и без интерфейса(в который мы вложили необходимые методы), нам бы пришлось три раза определять функции с одним и тем же кодом по сути:
farm(a AM), farm(e Earthshaker)... То есть это дублирование кода, при чем в нашем коде это в наименьшем объёме, а ведь функции могут быть на 200 строк и что тогда будет с кодом?

Интерфейсы помогают нам использовать функцию полиморфиза(один раз написали функцию и теперь используем её везде )