
**Интерфейсы** - абстрактный тип, способный на добавление методов к разным структурам. Грубо говоря, это своего рода фильтр. Который определяет что должны уметь делать объекты(при этом он не отвечает за реализацию их методов). Говоря грубо, пример с розеткой. Ей все равно что мы в неё втыкаем, главное это вилка.

**Официальное понятие** - специальный тип данных в GO, представляющий из себя набор сигнатур методов, которые нужно реализовать его имплементации.(Грубо структура должна реализовать методы интерфейса) 

**Имплементация интерфейса = когда наш конкретный тип реализует все методы указанные в в интерфейсе**. Явной имплементации в го нету. Поэтому тут скорее дело в утиной типизации(duck typing) + статической типизации. То есть то что бегает, плавает, летает, крякает = утка. И проверяется так это или нет на этапе компиляции программы, что отличается от классического duck typing в любом другом языке. Грубо говоря, чтобы имплементировать интерфейс. нужно просто реализовать все его методы.

#### Объявление интерфейсов
```go
package main

type Runner interface {
	Run() string
}

type Swimmer interface {
	Swim() string
}

type Flyer interface {
	Fly() string
}
```

#### Состав интерфейса

![[Pasted image 20251105195830.png]]
3 стадии интерфейсного значения. 

1 - пустой интерфейс(нету типа данных, нету значения).
2 - непустой интерфейс(есть тип данных, нету значения).
3 - есть и значение и тип данных

**Интерфейсы поддерживают встраивание, так что можно поступить вот так:**
```go 
type Ducker interface {
	Runner
	Swimmer
	Flyer
}
```

```go
func main() {
	interfaceValues()
}

func interfaceValues() {
	var runner Runner // default value - nil
	fmt.Printf("Type: %T Value: %v\n", runner, runner)//Type: <nil> Value: <nil>
	
	if runner == nil {
		fmt.Println("Runner is nil")
	}
	
	//runner = int64(1) 
	// cannot use int64(1) (constant 1 of type int64)
	//  as Runner value in assignment: int64 does not implement Runner (missing method Run)
}
```
Если у интерфейса нет конкретного значения и конкретного типа он равен нулю. А также что будет если попробуем встроить интерфейс который не  будет поддерживать необходимые нам методы.

```go
	var unnamedRunner *Human
	fmt.Printf("Type: %T Value: %v\n", unnamedRunner, unnamedRunner) //Type: *main.Human Value: <nil>

	runner = unnamedRunner
	fmt.Printf("Type: %T Value: %v\n", runner, runner) //Type: *main.Human Value: <nil>

	if runner == nil {
		fmt.Println("Runner is nil")//В случае вызова метода здесь будет паника
	}
```
Вот здесь очень важный поинт, который еще и на собесах любят поспрашивать.  В чём тут весь смысл? Мы создаём nil pointer. И интерфейс уже не пустой. То есть у него уже есть значение - тип данных.  Наше условие сработает, он содержит **ConcreteType**(main.human), но при этом из-за того что проверка сработает могут быть потом большие проблемы с тем, что у нас не сработает наш метод. То есть интерфейс как бы не пуст и дойдёт до метода, но при этом возникнет паника(из-за того что структура пустая). Если посмотреть на состав интерфейса, он будет пустым только при условии если тип данных неизвестен и в значении nil.

```go
	namedRunner := &Human{"Джек"}
	fmt.Printf("Type: %T Value: %v\n", namedRunner, namedRunner)

	runner = namedRunner	
	fmt.Printf("Type: %T Value: %v\n", runner, runner) //Type: *main.Human Value: &{Джек}
```
#### Простейший пример

```go
package main

import "fmt"

type Hero interface {
	Blink()
	Ultimate()
}

type Am struct {
}

type Earthshaker struct {
}

type PaAssasin struct {

}

func (h Am) Blink() {
	fmt.Println("Я антимаг в доте. Я нажал блинк в лес и дальше пошёл бить крипов")
}

func (e Earthshaker) Blink() {
	fmt.Println("Я шейкер. Я нажал блинк в рошпит и сделал рампагу")
}

func(p PaAssasin) Blink() {
	fmt.Println("Я фантомка. Я блинканулась на противника и убила его с трех ударов.")
}
 
func(p PaAssasin) Ultimate() {
	fmt.Println("Мой ультимейт(пассивная способность сработал) и я зафармила кемп с одного удара")
}

func farm(h Hero) {
	fmt.Println("Я играю на герое")
	fmt.Println("Я бью крипов")
	h.Blink()
	h.Ultimate()
}

func main() {
	// antiMage := Am{}
	pa := PaAssasin{}

	farm(pa)
}

```
Для чего здесь интерфейсы? Видим три разных структуры(наши герои в доте), и без интерфейса(в который мы вложили необходимые методы), нам бы пришлось три раза определять функции с одним и тем же кодом по сути:
farm(a AM), farm(e Earthshaker)... То есть это дублирование кода, при чем в нашем коде это в наименьшем объёме, а ведь функции могут быть на 200 строк и что тогда будет с кодом?

Интерфейсы помогают нам использовать функцию полиморфиза(один раз написали функцию и теперь используем её везде )


	Легкий оффтопчик. Разница в прохождении элементов по map'е и slice'ам:
```go
package main

import (
	"fmt"
	"strconv"
	"time"
)

type PaymentInfo struct {
	ID          int
	Description string
	USD         int
	isCancelled bool
}

type PaymentModuleWithSlice struct {
	s []PaymentInfo
}

func (m *PaymentModuleWithSlice) AddInfo(info PaymentInfo) {
	m.s = append(m.s, info)
}

func (m PaymentModuleWithSlice) FindInfo(ID int) PaymentInfo {
	for _, info := range m.s {
		if info.ID == ID {
			return info
		}
	}

	return PaymentInfo{}
}

//---------------------------------

type PaymentMethodWithMap struct {
	m map[int]PaymentInfo
}

func (a *PaymentMethodWithMap) AddInfo(info PaymentInfo) {
	a.m[info.ID] = info
}

func (a PaymentMethodWithMap) FindInfo(ID int) PaymentInfo {
	s, ok := a.m[ID]
	if ok {
		return s
	}

	return PaymentInfo{}
}

func main() {

	pSlice := PaymentModuleWithSlice{}
	pMap := PaymentMethodWithMap{
		m: make(map[int]PaymentInfo),
	}

	
	//-----------------------------------------------------
	
	iterations := 200_000
	
	b4 := time.Now()

	for i := 0; i < iterations; i++ {
		info := PaymentInfo{
			ID:          i,
			Description: strconv.Itoa(i),
			USD:         i + i,
			isCancelled: false,
		}

		pMap.AddInfo(info)
	}

	fmt.Println("Map Add:", time.Since(b4))

	b4 = time.Now()

	for i := 0; i < iterations; i++ {
		info := PaymentInfo{
			ID:          i,
			Description: strconv.Itoa(i),
			USD:         i + i,
			isCancelled: false,
		}

		pSlice.AddInfo(info)
	}

	fmt.Println("Slice Add:", time.Since(b4))



//-------------------------------------------------------------------
	
	b4 = time.Now()

	for i := 0; i < iterations; i++ {
		info := pMap.FindInfo(i)
		_ = info
	}

	fmt.Println("Map Find:", time.Since(b4))

	b4 = time.Now()

	for i := 0; i < iterations; i++ {
		info :=  pSlice.FindInfo(i)

		_ = info
	}

	fmt.Println("Slice Info:", time.Since(b4))


	// info1 := PaymentInfo{
	// 	ID:          10,
	// 	Description: "IPhone 16 Pro",
	// 	USD:         900,
	// 	isCancelled: false,
	// }

	// pSlice.AddInfo(info1)
	// pMap.AddInfo(info1)

	// pp.Println("Slice", pSlice)
	// pp.Println("Map:", pMap)

	// i1 := pSlice.FindInfo(10)
	// i2 := pMap.FindInfo(10)

	// fmt.Println(i1)
	// fmt.Println(i2)
}

```
```
Map Add: 68.0945ms
Slice Add: 137.4435ms
Map Find: 34.4867ms
Slice Info: 57.3287436s
```