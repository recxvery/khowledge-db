[[Работа с файлами]]

Начинаем с понятия чё такое ваще Stack. И легче всего объяснить что такое стек на примере с фишками в покере. Каждая ячейка данных это как одна фишка. Грубо говоря стек как раз таки и набор этих ячеек. И когда нам нужна какая-то ячейка мы достаём последнюю добавленную, грубо говоря по аналогии с покерными фишками, самая первая ячейка данных лежит в самом низу и достанем её мы в самую последнюю очередь.

Defer - по сути анонимная функция, чьё выполнение отложенно до выполнения родительской функции.

**То есть грубо говоря в самой главной функции сначала пойдёт "GL hf", потом то что в foo() и потом уже "GG"**

```GO
package main

  

import "fmt"

  

func main() {

    fmt.Println("GL hf")

  

    defer func() {

        fmt.Print("GG")

    }()

    foo()

}

  
  

func hello() {

    fmt.Println("helllooo1")

    defer func() {

        fmt.Print("hello 2")

    }()

    fmt.Println("Дароу бандиты12")

    fmt.Println("Дароу 122")

    fmt.Println("Дароу 123")

}

  

func foo() {

    defer func() {

        fmt.Println("Defer1")

    } ()

  

    defer func() {

        fmt.Println("Defer2")

    } ()

  

    defer func() {

        fmt.Println("Defer3")

    } ()

  
  

    fmt.Println("f00")

}
```


Что ещё интересно, мы не просто так разбирали понятие стека изначально и на примере функции foo(), наглядно объясняется, что к чему на самом деле. Грубо говоря три отложенных вызова функции как раз и образуют стек. Снизу - вверх, то есть сначала выходит "f00", потом "Defer3" и потом остальное. Так как данные уходят сверху - вниз.

**Вывод:**
```
GL hf
f00
Defer3
Defer2
Defer1
GG
```

Наглядный рисунок для понимания: 
![[Pasted image 20250608183635.png]]

Ещё один более интересный пример, для чего и как defer встречаются на практике.

**Код:**
```
func database() {
    //cоздать подключение
    
    defer func() {
            //закрыть подключение
    }
    boolean := true
    
    if boolean {
        //закрыть подключение
        return
    } else {

    }

    for i:=1; i <= 5; i++ {

        if i % 2 == 0 {
            //закрыть подключение
            return
        } else {
            //закрыть подключение
            return
        }

    }

    //закрыть подключение

}
```

Есть у нас условная база данных, создаём подключение, есть переменная, много ветвлений, цикл, а нам надо закрыть подключение ибо если не закроём то пизда проду, ну и нам в том числе. Постоянно в ручную закрывать подключение очень запарно ибо рано или поздно человек обосрётся и проворонит, что-то. Да и это просто не шибко удобно. Для этих целей берём и создаём отложенную функцию. Когда одно из условий выполнится, сработает return и функция выполнится. Вот и мы берём закрываем подключение после этого.

```GO
func B() {
  defer fmt.Println(1)
  defer fmt.Println(2)
  A()
}

func A() {
  defer fmt.Println(3)
  defer fmt.Println(4)
}
```

![[Pasted image 20251106174007.png]]