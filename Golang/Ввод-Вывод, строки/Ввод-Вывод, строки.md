https://pkg.go.dev/fmt
[[strings + прочие библиотеки]]
[[package-variables-data types(типы данных)]]
[[Работа с файлами]]

## fmt.Scan

это типо input’а в питоне. но тут со своими приколами. то есть он останавливается при пробелах и ты не сможешь без костылей написать строку из 2ух слов в переменную. Спросишь как этого избежать?

```Go
package main

import (
    // импортируем два пакета – bufio и os
    "bufio"
    "os"
    
    // с этим пакетом мы уже знакомы
    "fmt"
)

func main() {
	// Создаем новый reader чтобы считывать строки из консоли
	reader := bufio.NewReader(os.Stdin)
	
	fmt.Println("Введите предложение:")

	// Считываем строку до символа первого нажатия Enter
	input, _ := reader.ReadString('\n') //"_"x для игнора ошибки
	//которая возникла при попытке считать пользовательский ввод

	// Выводим считанную строку
	fmt.Println("Вы ввели:", input)
}
```

  

Также надо обязательно ставить знак амперсанда перед переменной чтобы записывалось значение, я честно пока до конца не ебу с чем это связано. Там че то с памятью, но так уж заведено.3

> Чтобы сохранить пользовательский ввод в переменную X, нужно передать ее в функцию fmt.Scan() с амперсандом (&) перед ней.

  

```Go
    fmt.Scan(&a, &b, &c, &d)
```

  

Ещё если допустим у нас 4 значение как выше и ты ввёл только три, то прога будет ждать пока ты введёшь еще данные, похоже чем то на list(map(int, input))) хз)

  

## **Форматирование строк**

Делается с помощью fmt.Printf и как я понял, чтобы перенести переменную на место в строке нужно.

```Go
fmt.Printf("Ваш индекс массы тела: %.1f", IMT) //передасться число и 1 знак после .
	
fmt.Printf("Ваш индекс массы тела: %v", IMT) //для самого обычного вывода

```

```go
result = append(result, fmt.Sprintf("%v, %s: %s\n", i+1, word, stroke))
```

В данном случае **%v** выводит переменную в её типе данных по умолчанию, а **%s** переводит не интерпретированные байты (205, 208 и т.д) в интерпретированные байты строки.

**Чтобы вывести тип данных переменной используем %T** 

```go
fmt.Printf("Type: %T, Value: %v\n", defaultMap, defaultMap)
```

![[Pasted image 20250719012258.png]]




### Работа с многострочными строками

тут просто ставится `text` и максимально точно всё выводится на экран. то есть каждый пробел, табуляция, даже знак '\n' из-за чего код может выглядеть по уродски. Так что как я понял практика не самая популярная.
## Sprintf

так ну грубо говоря это нам нужно просто чтобы склеивать строки в переменную по типу:

```Go
	result := fmt.Sprintf("Ваш индекс массы тела: %.0f", IMT)
	fmt.Print(result)
```

  

Наглядное отличие от Print:

![[мусор/image 10.png|image 10.png]]

  

## Узнаём длину строки:

Есть два способа сделать это:

1. Тут всё просто. Но он подходит сугубо для английских букв/цифр/символов, чтобы без других знаков и прочего ибо по-другому символы других языков будут занимать больше байтов
2. А вот руны наоборот почти всегда считают точное количество символов, хотя нужно поебаться со сторонними библами и прочем

```Go
	text := "ЖОПА"
	lenString := len(text) //8
	
	lenRunes := utf8.RuneCountInString(text)
	fmt.Print(lenRunes)//4

	
	text = "pisya"
	lenString := len(text) //5
	
	lenRunes := utf8.RuneCountInString(text)
	fmt.Print(lenRunes)//5
```

## **Делаем строку заглавной**

```go
	reader := bufio.NewReader(os.Stdin)

	songName, _ = reader.ReadString('\n')

	songName = strings.ToUpper(songName)
```

## Если нужно убрать пробелы, превратить строку в slice и при этом мы используем bufio.reader

```go
	reader := bufio.NewReader(os.Stdin)
	arr1, _ := reader.ReadString('\n')
	arr2, _ := reader.ReadString('\n')
	arrray1, arrray2 := strings.Fields(strings.TrimSpace(arr1)), strings.Fields(strings.TrimSpace(arr2))
```