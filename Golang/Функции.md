[[Условия]]
[[Структуры]]
[[func init()]]
[[Defer]]

Самое странное что уже поразило меня с самого начала то что здесь имеет значение регистр первого символа функции. То есть типо если функция с большой буквы то она используется в других пакетах и публичная, а если с маленькой то только в одном пакете.

  
Синтаксис базовый, единственное что надо указывать тип данных передающихся значений, ну как будто бы в этом нет ничего удивительного для языка со строгой типизацией:  

```Go
func calculateIMT(userWeight, userHeight float64) float64 {
	const IMTPower = 2
	IMT := userWeight / math.Pow(userHeight / 100, IMTPower)
	return IMT
}

//поясняя float64 который не в скобках даёт нам понимание типа данных, значения
//которого мы возвращаем
```

  

Как вернуть сразу несколько значений?

```Go
func getUserInput() (float64, float64) {
	var userWeight, userHeight float64
	fmt.Println("Введите рост в сантиметрах: ")
	fmt.Scan(&userHeight)
	fmt.Println("Введите вес: ")
	fmt.Scan(&userWeight)
	return  userHeight, userWeight
}
```

  

Сокращенный синтаксис

```Go
func getUserInput() (userweight float64, userheight float64) {
	fmt.Println("Введите рост в сантиметрах: ")
	fmt.Scan(&userheight)
	fmt.Println("Введите вес: ")
	fmt.Scan(&userweight)
	return 
}
```

В функциях у нас копии переменных, а не их оригиналы.

## Рекурсия в GO(ща будет  больно)

Рекурсия - функция которая вызывает саму себя(ну это мы итак знаем). Перейдём более к детальному разбору как она работает ибо у меня всегда были проблемы с этим.

Итак прежде всего у нас есть вот такая функция нахождения факториала рекурсивным методом:

```go
package main

import (
	"fmt"
)

func factorial(n int) int {

	if n == 1 {
		return 1
	}
	
	return factorial(n - 1) * n
}

func main() {
	// не изменяйте функцию main!!
	var n int
	fmt.Scan(&n)

	fmt.Println(factorial(n))
}

```


**Рекурсивный случай** - минимальная работа, которую мы можем выполнить. В данном случае строка:

```go
	return factorial(n - 1) * n
```

Ещё есть **базовый случай** - при котором работа уже сделана и делать нам ничего больше не нужно. То есть когда число дошло до 1. Факториал не нужно рассчитывать уже. Строчки:

```go
	if n == 1 {
		return 1
	}
```

![[Pasted image 20250814070047.png]]
вот как это начинается

![[Pasted image 20250814070110.png]]
Четвертый вызов функции возвращает 2 предыдущему вызову функции и удаляется из стека.

![[Pasted image 20250814070145.png]]
Третий рекурсивный вызов

![[Pasted image 20250814070209.png]]
второй вызов

![[Pasted image 20250814070221.png]]
последний вызов

Как это работает? Я очень долго не понимал почему мы в данной функции возвращаем 1. И только потом понял в чём дело, пошагово разберу. Первое это то что мы возвращаем 1, но это не останавливает функцию. Оно возвращает 1 не в factorial(n), а в factorial(n - 1). То есть вот как это будет выглядеть далее:

```go
return factorial(1) * 2 → return 1 * 2 → return 2
```

```go
return factorial(2) * 3 → return 2 * 3 → return 6
```

Потому что `return 1` — **это не конец всей функции**, а **ответ только для `factorial(1)`!**

- Каждый вызов `factorial(n)` **ждёт**, пока `factorial(n-1)` вернёт ему число.    
- Как только получает его — **умножает на своё `n`** и передаёт дальше.


