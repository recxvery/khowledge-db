**ВСЕ аксиомы c небуферизованным:**
![[Pasted image 20260129151149.png]]

**ПОЛНАЯ ТАБЛИЦА**
![[Pasted image 20260129151324.png]]

Здесь видим микропаттерн генератор(создание канала внутри функции и его передачу). Особенность этого паттерна в том что между созданием канала и его передачей не должно быть никаких блокирующих операций. Вся запись в канал должна проходить в отдельной горутине.
Можно сделать канал только на чтение при этом в функции мы можем записывать в него:
```go
func writer() <-chan int {
	ch := make(chan int)

	go func() {
		for i := range 5 {
			ch <- i + 1
		}
		close(ch)

	}()

	return ch
}
```

Допустим мы захотели сделать двух писателей и для этого мы сделали ещё одну горутину. Чтобы они закрывались нормально и отрабатывали нормально, без`deadlock'a`, нам нужно добавить `waitGroup'у`. + чтобы не было блокирующих операций **ВНЕ ГОРУТИН**. Поэтому получаем вот что:

```go
func writer() <-chan int {
	ch := make(chan int)
	wg := &sync.WaitGroup{}

	wg.Add(2)
	go func() {
		defer wg.Done()
		for i := range 5 {
			ch <- i + 1
		}
	}()

	go func() {
		defer wg.Done()
		for i := range 5 {
			ch <- i + 11
		}
	}()

	go func() {
		wg.Wait()
		close(ch)
	}()
	
	return ch
}

func main() {
	ch := writer()

	for {
		v, ok := <-ch
		if !ok {
			break
		}
		println(v)
	}

	time.Sleep(1 * time.Second)
}

```