# Grid

# Содержание

- [display: grid](#4)
- [grid-template-columns: 100px 100px 100px;](#7)
- [grid-template-rows: 100px 100px 100px;](#16)
- [На практике:](#19)
- [grid-auto-rows](#23)
- [Выравнивание](#29)
    - [justify-content](#32)
    - [align-content](#37)
    - [align-items](#41)
    - [justify-items](#46)
    - [justify-self](#51)
- [grid-column-start/end, grid-row-start/end](#56)
- [Задаём отдельный размер для ячеек](#68)
    - [grid-column: span/grid-row: span](#69)
    - [через наименования столбцов/строчек](#73)
    - [auto-fill/auto-fit](#78)
        - [difference:](#83)
- [АДАПТИВНЫЙ ГРИД](#92)
    - [Заполнение(grid-auto-flow:dense)](#99)

# display: grid

думаю тут и объяснять нечего. прост переводим всё в режим сетки

![image.png](2024-2025/Frontend%20development/CSS/Grid/image.png)

## grid-template-columns: 100px 100px 100px;

итак получается делим сетку по столбцам. указанные размеры означают следующие (горизонтально будет отображаться 3 столбца по 100пкс в ширину)

В гридах лучше избегать размеров процентов, вместо них там есть фракции они куда лучше подходят. 

чтобы поделять например на 3 равные части:

```css
  grid-template-columns: 1fr 1fr 1fr;

```

и это не значит что надо писать везде 1 for real для каждого элемента, можно лаконично и кратко:

```css
  grid-template-columns: repeat(10, 1fr); /*для 10 элементов сразу*/
   grid-template-columns: repeat(10, 1fr 2fr) /*чередуем размеры элементов*/
```

## grid-template-rows: 100px 100px 100px;

тоже самое что и для колонок только для строк

## На практике:

![image.png](2024-2025/Frontend%20development/CSS/Grid/image%201.png)

```css
.container {
  display: grid;
  /* grid-template-rows: 100px 100px 100px 50px; */
  grid-template-columns: 1fr 1fr;
  grid-template-rows: repeat(10, 100px 200px);
  gap: 42px;
}
```

## grid-auto -rows

```
  grid-auto-rows: minmax(100px, auto);

```

Короче штучка как min или max. Указываем минимальное значение в скобках, и в случае если контент будет больше то увеличиваем строку.

# Выравнивание(ну че ебана в рот. погна наху)

Тут всё обычно как у флексов за исключениями которые я здесь распишу.

## justify-content

выравнивает весь грид по всему wrapper’у

```css
  justify-content: center;

```

![image.png](2024-2025/Frontend%20development/CSS/Grid/image%202.png)

## align-content

тоже самое что и justify-content только по другой оси

## align-items

center:

![image.png](2024-2025/Frontend%20development/CSS/Grid/image%203.png)

вот так ведут себя колонки то есть они выравниваются относительно ячеек

## justify-items

center:

![image.png](2024-2025/Frontend%20development/CSS/Grid/image%204.png)

то есть тут уже выравнивание идёт по оси Х

## justify-self

тоже самое что и выше только для каждого элемента

![image.png](2024-2025/Frontend%20development/CSS/Grid/image%205.png)

```css
.item_5 {
  justify-self: center;
  align-self: end;
}

```

## grid-column-start/end, grid-row-start/end

Определяем сколько места занимает ячейка:

```css
.item_3 {
  grid-column-start: 1;
  grid-column-end: 3;
  grid-row-start: 2;
  grid-row-end: 6;
}
```

grid-column получаем что ячейка занимает всю колонну. grid-row получаем что ячейка занимает 3 ряда ну или: 

![image.png](2024-2025/Frontend%20development/CSS/Grid/image%206.png)

ну и таким образом можно тупа менять порядок элементов.

```css

.item_7 {
  grid-row-start: 1;
  grid-column-end: 2;
}

```

```css
.item_8 {
  grid-column: 2/2;
  grid-row: 1/1;
}
```

более короткий варик

код смертi:

```css
.item_11 {
  grid-column: 1 / span 3 ;
}

```

# Задаём отдельный размер для ячеек

## grid-column: span/grid-row: span

```css
.item_11 {
  grid-column: span 2; 
  grid-row: span 2; 
}
span - указывает сколько ячеек надо объеденить
```

![image.png](2024-2025/Frontend%20development/CSS/Grid/image%207.png)

## через наименования столбцов/строчек.

```css
.wrapper {
  display: grid;
  grid-template-columns: [s_left] 200px 200px [s_sidebar] 1fr 1fr [s_right];
  grid-template-rows: [y_start] repeat(3, 1fr) [y_end];
  gap: 20px;
}

.item_9 {
  grid-row: y_start/y_end;
}
```

![image.png](2024-2025/Frontend%20development/CSS/Grid/image%208.png)

## auto-fill/auto-fit

```css
  grid-template-columns: repeat(auto-fill, 300px);

```

![image.png](2024-2025/Frontend%20development/CSS/Grid/image%209.png)

![image.png](2024-2025/Frontend%20development/CSS/Grid/image%2010.png)

### difference:

auto-fill достраивает ещё один грид элемент если есть место

![image.png](2024-2025/Frontend%20development/CSS/Grid/image%2011.png)

это по хорошему бафает  возможности для адаптивной вёрстки

auto-fit упирается в кол-во элементов и не достраивает ни-ху-я

![image.png](image%2012.png)

# АДАПТИВНЫЙ ГРИД(ЧУЮ ЗАПАХ ГОВНА)

а наёбочка для уебка. здесь на удивление всё легче некуда тупо набор из трёх функций обеспечивает можно сказать фулл адаптив: 

1 строчка >>>> адаптив

```css
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
```

![image.png](image%2013.png)

## Заполнение(grid-auto-flow:dense)

вот пожалуйста код и проблемы в нём:

```css
.wrapper {
  display: grid;
  grid-template-columns: repeat(3, 100px);
}

.item_3 {
  grid-column: 1/-1;
}

.item_4 {
  grid-column: span 2;
}

.item_5 {
  grid-column: span 2;
}

```

![image.png](image%2014.png)

Решение с помощью grid-auto-flow: dance:

```css
.wrapper {
  display: grid;
  grid-template-columns: repeat(3, 100px);
  grid-auto-flow:dense
}

.item_3 {
  grid-column: 1/-1;
}

.item_4 {
  grid-column: span 2;
}

.item_5 {
  grid-column: span 2;
}

```

![image.png](image%2015.png)

то есть оно типо восстанавливает дыры. но на самом деле метод так себе так как он заполняяет первым вмещаещемся элементов тут можно спокойно обосраться как с orderom потому что голосовой помощник найдёт 3 элемент сначала потом 4ый и потом 5ый то есть с точки зрения доступности такое се.

# grid-template-area(NEW META)

Итак это у нас уже грид по шаблонам:

дефолт шаблон:

```css
.wrapper {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(3, 1fr);
  grid-template-areas:
    "header header header header"
    "sidebar content  content content"
    "footer footer footer footer ";
}
.header {
  grid-area: header;
}

.sidebar {
  grid-area: sidebar;
}

.content {
  grid-area: content;
}

.footer {
  grid-area: footer;
}
    
```

```html
    <div class="wrapper">
        <div class="item header">Header</div>
        <div class="item sidebar">Sidebar</div>
        <div class="item content">Content</div>
        <div class="item footer">Footer</div>
    </div>
```

Итог: 

![image.png](image%2016.png)

Максимально казуальная читерная хрень

Вот так интересно выглядят сетки: 

![image.png](image%2017.png)