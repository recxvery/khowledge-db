математическая нотация, используемая для описания асимптотической сложности алгоритмов, в частности, того, как время выполнения или потребление памяти алгоритмом растет с увеличением размера входных данных

![[Pasted image 20250713004257.png]]
#### **Cуществует две сложности алгоритмов по времени и по памяти.**
##### По времени
Сколько операций займёт по времени по программа в зависимости от входных данных
##### По памяти
Сколько памяти уйдёт на исполнение программы.

В целом нас всегда интересует **худший сценарий развития** при работе с алгоритмами. Хороший пример, допустим резко хайпанёт бот в тг и нам нужно чтобы он не лёг от большого количества пользователей.

**Верхняя граница сложности алгоритма в зависимости от входных данных и есть Big О**

![[Pasted image 20250713010349.png]]тут наглядно показано. верхняя граница - синий график. красный график же количество операций. 

Короче, я более наглядно осознал для себя кое-что. Вот берём самый сука простой цикл и условно в нём у нас есть кол-во пользователей, кол-во операций которые нам нужно проделать с ними. Код ниже:
```go
func main() {
	start := time.Now()

	n := 30
	k := 0
	for i := 0; i < int(math.Pow(2, float64(n))); i++ {
		k += 1
	}

	elapsed := time.Since(start).Milliseconds()
	fmt.Printf("Результат: %v\nВремя работы программы составило: %v ms", k, elapsed)
}
```
что получаем при 30 пользователях? 1 миллион операций и 30 секунд выполнения задачи. и это при 30 пользователях а при 40 

![[Pasted image 20250713012331.png]]
Наглядное сравнение задач по уровню операций выполняемых в них.

и сравнение их графиков:
![[Pasted image 20250713012511.png]]

Тут очень интересная механика идёт. Вообще чем больше я разбираю, тем больше понимаю. Короче, суть в том что вот есть у нас пример.

$500n = O(n).$

И суть его в том, что вот условно у нас есть цикл и там 500 операций. Дело не в их количестве, а в самих количествах этих циклов. То есть вот:
![[Pasted image 20250713013528.png]]

Вот например разбор функции и создаём сложное выражение:
![[Pasted image 20250713013739.png]]
**Итог**:    $n^2 + n + 1$

И далее получаем что по сути:

$n^2 + n + 1 = O(n^2)$

**Почему?**
потому что $n^2$ уходит в бесконечность и этот n нам становится абсолютно не важен потому что по сути этот **n** вообще не влияет на скорость роста алгоритма при больших **n**. То есть формула **$n + 1$** абсолютна незначительна на фоне **$n^2$**

То есть вот по сути:
![[Pasted image 20250713015832.png]]
по началу вроде красный график вида $4*x^2 + 5*x + 1$ больше, но после точки ![[Pasted image 20250713020055.png]]
синий график вида $10*x^2$ беспощадно будет его перекрывать вплоть до **бесконечности**

То есть по факту суть в том что вот у нас пример
![[Pasted image 20250713020223.png]]
абсолютно похуй на $5600*logn$ мы проебались уже на $2^n$

Большое О это теоретическая оценка. Всегда. На практике может быть и такое что в с Big O алгоритм может работать хуже чем с реальными данными, в таком случае алгоритм с real-date будет все равно использоваться. Это вообще неидеальная оценка она не учитывает сложность операций(сложить int'ы и float'ы абсолютно разные вещи), кэширование

## Примеры операций

##### O(1)
```go
func main() {
	for i:=0; i < 100000000; i++ {
		1ops
	}
	O(1)
}
```
##### O(n) - линейная
```go
    for i:=0; i < 100*n; i++ {
        ops
        ops
        ops
    }
    O(n) //100*3 = 300*n
```

##### O(n, m)
```go
	f(n, m)
	for i:=0; i < 100*n; i++ {
		for j:=0; i < 100*m; i++{
			ops
			ops
		}
	}
	O(n * m) // мы не может обросить что-то, при этом мы не понимаем их взаимосвязь
```
##### O(n + m) по сути или-или потому что не знаем что больше
```go
	f(n, m)
	for i:=0; i < 100*n; i++ {
		ops
	}
	for j:=0; i < 100*m; i++{
			ops
		}
	O(n + m)
```

##### Тоже O(n^2), но функция квадратичная
```go
	f(n)
	for i:=0; i < n; i++ {
		for j:=i; i < n; i++ {
			ops
		}
	}
```
![[Pasted image 20250713023548.png]]


## Наглядный пример как работает capacity:
![[Pasted image 20250713050942.png]]
где **cost** - кол-во операций

И на этом примере  получаем **ароматизационный** **анализ** то есть каждый платит в среднем чуть больше, чтобы покрыть редкий случай. Или как тут, у нас есть окна со сложным кол-вом операций, но в основном операции мелкие. 

Вот упрощенная версия:
![[Pasted image 20250714180133.png]]
![[Pasted image 20250714180147.png]]
![[Pasted image 20250714180157.png]]