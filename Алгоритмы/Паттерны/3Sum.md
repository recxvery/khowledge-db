```go

func threeSum(nums []int) [][]int {
	sort.Ints(nums) //[-4, -1, -1, 0, 1, 2] O(n log n) //сортируем массив иначе у нас будут по кд повторяющиеся тройки
	result := [][]int{}
	for i := range len(nums) - 2 { //len(nums) - 2 потому что таким образом мы высобождаем место под left/right (если не написать то left == right при последней итерации i)
		//пропускаем дубликаты. каким образом? если у нас nums[i] == -1; nums[i + 1] == -1, цикл пропустит итерацию
		if i > 0 && nums[i] == nums[i - 1] {
 			continue
		}

		//classic 2 sum algo
		left, right := i + 1, len(nums) - 1

		for left < right {
			sum := nums[i] + nums[left] + nums[right] //складываем сумму. 1. -4 + (-1) + (2) == -3 < 0 / 2. -4 + (-1) + (2) == -3 < 0. / 3. -4 + 0 + 2 == -2
			// 4. -4 + 1 + 2 == -1
			//нашли сумму
			if sum == 0 {
				result = append(result, []int{nums[i], nums[left], nums[right]})

				//скипаем дубликаты(по сути тот же самый алгоритм что и выше только тут ещё проверка на пересечения указателей)
				for left < right && nums[left] == nums[left + 1] {//						                                                          *(left = 4)
					left++ //для чего нужен этот цикл и следующий? Для того чтобы унас не возникло одинаковых троек. Например массив [-2, -1, -1, -1, 1, 1, 1] на итерации
					//i = 0, left = 4, смотрим и видим что у нас следующий элемент равен, значит пропускаем чтобы не было повторяющихся троек.(чтобы в результат попал только
					//один слайс)

				}

				for left < right && nums[right] == nums[right - 1] {
					right--
				}

				left++ //если не указываем здесь ничего то указатели просто навечно застревают в цикле left < right 
				right--
			} else if sum < 0 {
				left++ //увеличиваем сумму если она меньше 1. 1 + 1  == 2. / 2. 2 + 1 == 3. / 3. 3 + 1 == 4 // 4. 4 + 1 == 5 - выход из цикла
			} else {
				right-- //уменьшаем если большая
			}
		}
	}

	return result
}

```
Здесь приведён подробный разбор


[V] Решил после разбора (тем не менее сам понял о том что нужно опять использовать разницу как в самом первом Two Sum, понял что нужно отсортировать массив. не понял только как нужно проводить проверку)

**Паттерн**: Two Pointers + сортировка массива + проверки на повторения(дубликаты)

**Моя ошибка**: как огня избегал O(n2) хотя здесь он был необходим для прохождения по всем элементам. 